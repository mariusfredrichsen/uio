# Synchronization, Critical Sections
### Exercise 1
```
co
    <await (x >= 3) x := x - 3> #P1
 ||
    <await (x >= 2) x := x - 2> #P2
 ||
    <await (x = 1) x := x + 5> #P3
oc
```

For the program to terminate under weak fairness, x must be in {6,1}.
The final values are x in {6,1} because every process must eventually be chosen. Therefor the values are guaranteed to go down by 5 or increase by 5.



### Exercise 2
```
co
    <await (x > 0) x := x - 1> #P1
 ||
    <await (x < 0) x := x + 2> #P2
 ||
    <await (x = 0) x := x - 1> #P3
oc
```
For the program to terminate under weak fairness, x must be in {0,1,-1}.
The final values are x in {0,1,-1} because every process must eventually be chosen. Therefor the value are guarenteed to increase by 2, or decause by 1 (by 2 different processes). 



### Exercise 3
```
int x := 10
bool c := true
co
    < await (x = 0) >           #P1
    c := false
 ||
    while (c) < x := x - 1 >    #P2
 ||
    # Part 2
    while (c) {                 #P3
        if (x < 0) < x := 10 > ;
    }
oc
```

We have (part 1):
- There might be a termination under weak fairness
- There might be a termination under strong fairness
- (part 2), there might be a termination under weak fairness, but there is a termination under strong fairness, because the termination condition can happen infinitely many times which means it can terminate. However it does not remain true so it might terminate under weak fairness.



### Exercise 4
```
bool enter1 := false, enter2 := false ;
int turn := 1;
process P1 {
    while (true){
    enter1 := true                  # entry protocol
    while(enter2) {
        if (turn = 2) {
            enter1 := false ;
            while(turn = 2) skip;
            enter1 := true;
        }
    }
    critical section;
    enter1 := false ;               # exit protocol
    turn := 2;
    non-critical section;
    }
}
process P2 {
    while (true) {
    enter2 := true                  # entry protocol
    while(enter1) {
        if (turn = 1) {
            enter2 := false ;
            while(turn = 1) skip;
            enter2 := true;
        }
    }
    critical section;
    enter2 := false ;               # exit protocol
    turn := 1;
    non-critical section;
    }
}
```

There is:
- mutual exclusion
- absence of deadlock
- absence of unnecessary delay
- eventual entry, there must be a will to enter

There could be infinite possible times one process can pass the others.


### Exercise 5
```
int lock := 0;
process CS[i = 1 to n] {
    while(true) {
        <await (lock = 0)>;
        lock := i ;
        Delay;
        while(lock != i) {
            <await (lock = 0)>;
            lock := i ;
            Delay;
        }
        critical section;
        lock := 0;
        non-critical section;
    }
}
```

There is:
- Not mutual exclusion
- Absence of deadlock
- Absence of unnecessary delay
- Not eventual entry

If delay is added and spins enough to correct the locking mechanism then there is:
- Mutual exclusion
- still, Absence of deadlock
- still, Absence of unnecessary delay
- Not eventual entry

Delay by definition waits for a another process to do a operation



### Exercise 6
```
flip (lock)
    < lock := (lock + 1) % 2    # flip the lock
    return (lock) >             # return the new value
```

```
int lock := 0;              # shared variable
process CS[i = 1 to 2]{
    while(true){
        while(flip(lock) != 1) {
            while(lock != 0) skip;
        }
        critical section;
        lock := 0;
        non-critical section;
    }
}
```

The lock is written in a way that lets one of the processes retry to enter every time. The flip mechanism turns it back to 1 after failing the first time and then both could be in the critical section.

Yes, because the lock value would be 2 and not 0 after failing to enter the critical section.
