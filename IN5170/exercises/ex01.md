### Exercise 1 (Parallelism and concurrency)
Yes, I think so. This is because when running concurrent processes you can run multiple processes that use the same resources which might be in the cache. Instead of running a single process that uses a set of resources then laster uses another, after that run another process that uses the same resources, but this time the cache is filled with some other resources.

### Exercise 2 (Synchronization)
```
string buffer ; # contains one line of the input
bool done := false;
process Finder { # find patterns
string line1 ;
while (true) {
    wait for buffer to be full or done to be true;
    < **await** (buffer != null || done)> 
    if (done) break;
    line1 := buffer ;
    signal that buffer is empty;
    look for pattern in line1;
    if (pattern is in line1)
        write line1;
    }
}
process Reader { # read new lines
    string line2 ;
    while (true) {
        read next line of input into line2 or set EOF after last line;
        if (EOF) {done := true; break;}
        wait for buffer to be empty;
        < **await** (buffer = null) >
        buffer := line2 ;
        signal that buffer is full;
    }
}
```




### Exercise 3 (Producer-consumer)
```
**int** buffer;

**process** Producer {
    **int** a[N]; p := 0;
    **while** (p < N) {
        < **await** (buffer = null) >
        buffer := a[p];
        p := p+1;
    }
}

**process** Consumer {
    **int** b[N]; c := 0;
    **while** (c < N) {
        < **await** (buffer != null); >
        b[c] := buffer;
        buffer := null;
        c := c+1;
    }
}
```

Base it more on the buffer itself since its already global.



### Exercise 4 (Executions and atomicity)
```markdown
**int** x := 0, y := 0;
**co**
    x := x + 1; # S1
    x := x + 2; # S2
||
    x := x + 2; # P1
    y := y âˆ’ x; # P2
**oc**
```

#### 1. Atomic
If the whole assignments are atomic then the possible values would be based on which one of them starts first. Therefor:
x = 5
y = -5

or 

x = 5
y = -2

#### 2. Three atomic actions


