# Channels and Message passing
## Exercise 1 (Partition filter)
```
chan out1(int), out2(int), in(int);

process Partition() {
    int v, first_v;

    receive in(first_v);
    if (first_v = EOS) {send out1(EOS); send out2(EOS); return;}

    receive in(v);

    while (v != EOS) {
        if (v >= first_v) {
            send out1(v);
        } else {
            send out2(v);
        }
        receive in(v);
    }

    send out1(first_v); 
    send out1(EOS); 
    send out2(EOS);


}
```

From the solution:
empty(in) ∧ in[1] = v ∧ out1[m] = v ∧ out1[m + 1] = EOS ∧ out2[(n − m) + 1] = EOS
∧ ∀1 ≤ i ≤ m, ∀1 ≤ j ≤ (n − m) : out1[i] < out2[j]
∧ ∀1 ≤ i ≤ n : (∃j1 ≤ j ≤ m : in[i] = out1[j]) ∨ (∃1 ≤ j ≤ (n − m) : in[i] = out2[j])


## Exercise 2 (Readers/writers & server with asynchronous message passing)

```


chan r(int client_id, str client_type, str operation_type);
chan s[n](bool accepted);

process Server {
    queue<int> readers, writers;
    int nr, nw, client_id;
    str client_type; operation_type;

    while (true) {
        receive r(client_id, client_type, operation_type);

        if (operation_type = "GET") {
            if (client_type = "READ") {
                if (nw = 0 and empty(writers)) {
                    nr++; 
                    send p[client_id](true);
                } else {
                    insert(readers, client_id);
                }
            } else { // "WRITE"
                if (nr = 0 and nw = 0) {
                    nw++;
                    send s[client_id](true);
                } else {
                    insert(writers, client_id);
                }
            }
        } else { // "POST"
            if (client_type = "READ") {
                nr--;
                if (nr = 0 and !empty(writers)) {
                    remove(writers, client_id);
                    nw++;
                    send s[client_id](true);
                }
            } else {
                nw--;
                if(nw = 0 and !empty(readers)) {
                    while(!empty(readers)) {
                        nr++;
                        remove(readers, client_id);
                        send s[client_id](true);
                    }
                } else if (nw = 0 and !empty(writers)) {
                    nw++;
                    remove(writers, client_id);
                    send s[client_id](true);
                }
            }
        }
    }
}

// from solution ^ ouf...
```


## Exercise 3 (Savings account)
```


int n_clients;
chan r(int client_id, str operation_type, int amount);
chan s[n_clients](int amount);

process bank {
    queue<Pair<int, amount>> withdrawers;

    int client_id;
    str operation_type;
    int amount;
    int asked_amount;
    int total_amount = 0;

    while (true) {
        receive r(client_id, operation_type, amount);

        if (operation_type = "DEPOSIT") {
            total_amount := total_amount + amount;

            while (!empty(withdrawers) and ((total_amount - asked_amount) >= 0)) {
                remove(withdrawers, Pair(client_id, amount));
                total_amount := total_amount - amount;
                send s[client_id](amount);

                if (!empty(withdrawers))
            }
        } else { // "WITHDRAW"
            if ((total_amount - amount) >= 0) {
                total_amount := total_amount - amount;
                send s[client_id](amount);
            } else { // negative
                insert(withdrawers, Pair(client_id, amount));
                asked_amount := amount;
            }
        }
    }
}

```

basically the same as the solution just different, cant be bothered to deal with the queue noe having a get_first function.


## Exercise 4 (Printers)

```

chan r