# Semaphores and Monitors

## Exercise 1 (Semaphores: Precedence graph)

```
Sem S1 = 0;
Sem S2 = 0;
Sem S3 = 0;

process T1 {
    body;
    V(S1);   // add 1
    V(S1);   // add 1
}

process T2 {
    P(S1);
    body;
    V(S2);
}

process T3 {
    P(S1);
    body;
    V(S3);
}

process T4 {
    P(S2);
    body;
    V(S3);
}

process T5 {
    P(S3);
    P(S3);
    body;
}
```


## Exercise 2 (Semaphores: Bear and honeybees)

```
H = 10
pot = 0

Sem H1 = 1;
Sem B1 = 0;
Sem W1 = 0;

process Bee[i=0 to n] {
    while (true) {
        P(H1)               // one bee at a time
        pot := pot + 1      // critical section
        if (pot = H) {
            V(B1)           // signal bear
            P(W1)           // wait for the bear to finish eating
        }
        V(H1)               // signal next bee
    }
}

process bear {
    while (true) {
        P(B1)                   // wait for pot to be full
        pot = 0                 // eat honey
        V(W1)                   // signal finished eating honey
    }
}
```



## Exercise 3 (Monitors: Signalling disciplines and SJN)

```
monitor ShortestJobNext {
    bool free := true;
    cond turn;

    procedure request(int time) {
        if ( free = false) wait(turn, time);
        free := false;
    }

    procedure release() {
        free := true;
        signal(turn);
    }
}
```

It works for signal and wait since the condition is already met and the thread gets to do its process immidietly. While for signal and continue we get a potential error when the process is put back to the queue and there might be another process that makes the condition false. Signal and continue needs a while check to re-check the condition.


## Exercise 4 (Monitor solution: to the readers/writers problem)

```markdown
// signal and continue
monitor RW Controller {                             # Invariant: (nr = 0 ∨ nw = 0) ∧ nw ≤ 1
    int nr := 0, nw := 0                            # number of readers, number of writers
    cond oktoread;                                  # signalled when nw = 0
    cond oktowrite;                                 # signalled when nr = 0 and nw = 0

    procedure request read() {
        while (nw > 0) wait(oktoread);
        nr := nr + 1;
    }

    procedure release read() {
        nr := nr − 1;
        if nr = 0 signal (oktowrite);               # wake up one writer
    }

    # c
    procedure release read() {
        nr := nr − 1;
        if (!empty(oktowrite) and nr = 0) {
            signal(oktowrite);                                # wake up one writer
        } else {
            signal(oktoread)
        }
    }

    procedure request write() {
        while (nr > 0 ∨ nw > 0) wait(oktowrite);
        nw := nw + 1;
    }

    # a
    procedure release write() {
        nw := nw − 1;
        signal(oktowrite);                          # wake up one writer
        while(!empty(oktoread)) signal(oktoread);   # wake up all readers
    }

    # b
    procedure release write() {
        nw := nw − 1;
        signal_all(oktowrite);                      # wake up all writer
        signal(oktoread);                           # wake up one readers
    }

    # c
    procedure release write() {
        nw := nw − 1;
        if (empty(oktoread)) {
            signal(oktowrite)
        } else {
            signal(oktoread);                           
        }
    }
}
```



```markdown
// signal and continue
monitor RW Controller {                             # Invariant: (nr = 0 ∨ nw = 0) ∧ nw ≤ 1
    int nr := 0, nw := 0                            # number of readers, number of writers
    cond oktoread;                                  # signalled when nw = 0
    cond oktowrite;                                 # signalled when nr = 0 and nw = 0
    queue q := empty;

    procedure request read() {
        enqueue(q, 0)                               # P = process
        while (nw > 0) wait(oktoread);
        nr := nr + 1;
    }

    procedure release read() {
        nr := nr − 1;
        X = inspect(q)
        if (X = 0) {
            signal(oktoread);                       # wake up all readers
        } else if (X = 1 and nr = 0) {
            signal(oktowrite);                          # wake up one writer
        }
        if (!empty(q)) dequeue(q)
    }

    procedure request write() {
        enqueue(q, 1)
        while (nr > 0 ∨ nw > 0) wait(oktowrite);
        nw := nw + 1;
    }

    procedure release write() {
        nw := nw − 1;
        X = inspect(q)
        if (X = 0) {
            signal(oktoread);                       # wake up all readers
        } else if (X = 1) {
            signal(oktowrite);                          # wake up one writer
        }
        if (!empty(q)) dequeue(q)
    }
}
```








