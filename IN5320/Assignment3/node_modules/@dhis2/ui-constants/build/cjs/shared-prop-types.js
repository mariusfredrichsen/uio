"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.statusPropType = exports.statusArgType = exports.sizePropType = exports.sizeArgType = exports.popperReferencePropType = exports.popperReferenceArgType = exports.popperPlacementPropType = exports.popperPlacementArgType = exports.insideAlignmentPropType = exports.insideAlignmentArgType = exports.buttonVariantArgType = void 0;
var _propTypes = require("@dhis2/prop-types");
var _propTypes2 = _interopRequireDefault(require("prop-types"));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
/**
 * Status propType
 * @return {PropType} Mutually exclusive status: valid/warning/error
 */
const statusPropType = exports.statusPropType = (0, _propTypes.mutuallyExclusive)(['valid', 'warning', 'error'], _propTypes2.default.bool);
// Exported for storybook
const statusArgType = exports.statusArgType = {
  table: {
    type: {
      summary: 'bool',
      detail: "'valid', 'warning', and 'error' are mutually exclusive props"
    }
  },
  control: {
    type: 'boolean'
  }
};
const buttonVariantArgType = exports.buttonVariantArgType =
// No description because it should be set for the component description
{
  table: {
    type: {
      summary: 'bool'
    }
  },
  control: {
    type: 'boolean'
  }
};

/**
 * Size variant propType
 * @return {PropType} Mutually exclusive variants:
 * small/large
 */
const sizePropType = exports.sizePropType = (0, _propTypes.mutuallyExclusive)(['small', 'large', 'extrasmall', 'fluid'], _propTypes2.default.bool);
const sizeArgType = exports.sizeArgType = {
  // No description because it should be set in the component description
  table: {
    type: {
      summary: 'bool',
      detail: 'size props are mutually exclusive'
    }
  },
  control: {
    type: 'boolean'
  }
};

/**
 * Inside alignment props
 * @return {PropType} PropType that validates the inside alignment.
 */
const insideAlignmentPropType = exports.insideAlignmentPropType = _propTypes2.default.oneOf(['top', 'middle', 'bottom']);
const insideAlignmentArgType = exports.insideAlignmentArgType = {
  description: 'Inside alignment of the component',
  table: {
    type: {
      summary: "'top' | 'middle' | 'bottom'"
    }
  },
  control: {
    type: 'select',
    options: ['top', 'middle', 'bottom']
  }
};

/**
 * Placement properties against reference element
 * @return {PropType} PropType that validates placements.
 */
const popperPlacementPropType = exports.popperPlacementPropType = _propTypes2.default.oneOf(['auto', 'auto-start', 'auto-end', 'top', 'top-start', 'top-end', 'bottom', 'bottom-start', 'bottom-end', 'right', 'right-start', 'right-end', 'left', 'left-start', 'left-end']);
const popperPlacementArgType = exports.popperPlacementArgType = {
  description: 'Placement properties relative to reference element',
  table: {
    type: {
      summary: 'string (one of several)',
      detail: 'see options in menu'
    }
  },
  control: {
    type: 'select',
    options: ['auto', 'auto-start', 'auto-end', 'top', 'top-start', 'top-end', 'bottom', 'bottom-start', 'bottom-end', 'right', 'right-start', 'right-end', 'left', 'left-start', 'left-end']
  }
};

/**
 * Either a DOM node, React ref or a virtual element
 * @return {PropType} Validate that prop is either a function or an
 * instance of an Element.
 */
const popperReferencePropType = exports.popperReferencePropType = _propTypes2.default.oneOfType([
// DOM node
_propTypes2.default.instanceOf(Element),
// React ref - React.useRef() or React.createRef()
_propTypes2.default.shape({
  current: _propTypes2.default.instanceOf(Element)
}),
// Virtual element
_propTypes2.default.shape({
  getBoundingClientRect: _propTypes2.default.func
})]);
const popperReferenceArgType = exports.popperReferenceArgType = {
  description: 'A reference to the element to position against: either a DOM node, React ref, \
        or an instance of an element',
  table: {
    type: {
      summary: 'DOM node | React ref | Virtual element'
    }
  },
  control: {
    type: null
  }
};