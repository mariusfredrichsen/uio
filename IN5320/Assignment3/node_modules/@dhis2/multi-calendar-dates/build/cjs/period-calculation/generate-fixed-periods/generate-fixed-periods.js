"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _dhis2CalendarsMap = require("../../constants/dhis2CalendarsMap");
var _getValidLocale2 = _interopRequireDefault(require("../../utils/getValidLocale"));
var _index = require("../../utils/index");
var _periodTypeGroups = require("../period-type-groups");
var _generateFixedPeriodsDaily = _interopRequireDefault(require("./generate-fixed-periods-daily"));
var _generateFixedPeriodsMonthly = _interopRequireDefault(require("./generate-fixed-periods-monthly"));
var _generateFixedPeriodsWeekly = _interopRequireDefault(require("./generate-fixed-periods-weekly"));
var _generateFixedPeriodsYearly = _interopRequireDefault(require("./generate-fixed-periods-yearly"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
/**
 * @param {Object} options
 * @param {string} [options.endsBefore] - Excludes all periods that end on or
 * after the provided date. This will help generating periods up to a certain
 * point (e.g. "now" or "in two weeks" when two open future periods are
 * allowed, like in the aggregate data entry app)
 */
const generateFixedPeriods = _ref => {
  var _dhis2CalendarsMap$re, _getValidLocale;
  let {
    periodType,
    year: yearString,
    endsBefore: _endsBefore,
    calendar: requestedCalendar,
    locale = 'en',
    yearsCount = 10,
    startingDay = 1
  } = _ref;
  let year;
  if (typeof yearString === 'number') {
    year = yearString;
  } else {
    if (!isNaN(yearString) && !isNaN(parseInt(yearString))) {
      year = parseInt(yearString);
    } else {
      throw new Error('year must be a number');
    }
  }
  const calendar = (0, _index.getCustomCalendarIfExists)((_dhis2CalendarsMap$re = _dhis2CalendarsMap.dhis2CalendarsMap[requestedCalendar]) !== null && _dhis2CalendarsMap$re !== void 0 ? _dhis2CalendarsMap$re : requestedCalendar);
  const validLocale = (_getValidLocale = (0, _getValidLocale2.default)(locale)) !== null && _getValidLocale !== void 0 ? _getValidLocale : 'en';
  const endsBefore = _endsBefore ? (0, _index.fromAnyDate)({
    calendar,
    date: _endsBefore
  }) : undefined;
  if (_periodTypeGroups.weeklyFixedPeriodTypes.includes(periodType)) {
    return (0, _generateFixedPeriodsWeekly.default)({
      year,
      periodType,
      calendar,
      startingDay,
      endsBefore
    });
  }
  if (_periodTypeGroups.yearlyFixedPeriodTypes.includes(periodType)) {
    return (0, _generateFixedPeriodsYearly.default)({
      year,
      periodType,
      locale: validLocale,
      calendar,
      endsBefore,
      yearsCount
    });
  }
  if (_periodTypeGroups.monthlyFixedPeriodTypes.includes(periodType)) {
    return (0, _generateFixedPeriodsMonthly.default)({
      year,
      periodType,
      locale: validLocale,
      calendar,
      endsBefore
    });
  }
  if (periodType === 'DAILY') {
    return (0, _generateFixedPeriodsDaily.default)({
      year,
      locale: validLocale,
      calendar,
      endsBefore
    });
  }
  throw new Error(`can not generate period for unrecognised period type "${periodType}"`);
};
var _default = generateFixedPeriods;
exports.default = _default;