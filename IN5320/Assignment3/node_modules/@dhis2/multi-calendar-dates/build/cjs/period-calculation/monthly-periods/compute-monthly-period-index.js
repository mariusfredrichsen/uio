"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _getStartingMonthForPeriodType = require("../get-starting-month-for-period-type");
var _monthNumbers = _interopRequireDefault(require("../month-numbers"));
var _periodTypeGroups = require("../period-type-groups");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const computeMonthlyPeriodIndex = _ref => {
  let {
    periodType,
    month,
    monthsInYear
  } = _ref;
  if (periodType === 'MONTHLY') {
    return month;
  }
  if (periodType === 'BIMONTHLY') {
    if (month % 2 === 0) {
      throw new Error(`Even numbers can't be a month for BIMONTHLY period type, received "${month}"`);
    }
    return Math.ceil(month / 2);
  }
  if (_periodTypeGroups.quarterlyFixedPeriodTypes.includes(periodType)) {
    return computeQuarterlyIndex(periodType, month, monthsInYear);
  }
  if (_periodTypeGroups.sixmonthlyFixedPeriodTypes.includes(periodType)) {
    return computeSixmonthlyIndex(periodType, month, monthsInYear);
  }
  throw new Error(`Unrecognized period type "${periodType}"`);
};
var _default = computeMonthlyPeriodIndex;
exports.default = _default;
const createPeriodTypeIndexes = (periodMonthIndex, monthsInYear) => {
  const indexesFromStartingMonthToEndOfYear = Array(monthsInYear - periodMonthIndex + 1).fill(null).map((_, i) => i + periodMonthIndex);
  return [...indexesFromStartingMonthToEndOfYear, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12].slice(0, 12);
};
const getMonthSlices = (monthIndexes, monthsPerSlice) => {
  const slices = [];
  for (let index = 0; index < 12; index += monthsPerSlice) {
    slices.push(monthIndexes.slice(index, index + monthsPerSlice));
  }
  return slices;
};
const computeSixmonthlyIndex = (periodType, month, monthsInYear) => {
  const monthName = (0, _getStartingMonthForPeriodType.getStartingMonthByPeriodType)(periodType);
  const periodMonthIndex = _monthNumbers.default[monthName].value;
  const monthIndexes = createPeriodTypeIndexes(periodMonthIndex, monthsInYear);
  const halves = getMonthSlices(monthIndexes, 6);
  return halves[1].includes(month) ? 2 : 1;
};
const computeQuarterlyIndex = (periodType, month, monthsInYear) => {
  const monthName = (0, _getStartingMonthForPeriodType.getStartingMonthByPeriodType)(periodType);
  const periodMonthIndex = _monthNumbers.default[monthName].value;
  const monthIndexes = createPeriodTypeIndexes(periodMonthIndex, monthsInYear);
  const quarters = getMonthSlices(monthIndexes, 3);
  if (quarters[1].includes(month)) {
    return 2;
  }
  if (quarters[2].includes(month)) {
    return 3;
  }
  if (quarters[3].includes(month)) {
    return 4;
  }
  return 1;
};