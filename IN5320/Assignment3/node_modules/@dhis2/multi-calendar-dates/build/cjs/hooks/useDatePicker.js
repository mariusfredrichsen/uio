"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useDatePicker = void 0;
var _polyfill = require("@js-temporal/polyfill");
var _react = require("react");
var _dhis2CalendarsMap2 = require("../constants/dhis2CalendarsMap");
var _index = require("../index");
var _helpers = require("../utils/helpers");
var _localisationHelpers = _interopRequireDefault(require("../utils/localisationHelpers"));
var _useCalendarWeekDays = require("./internal/useCalendarWeekDays");
var _useNavigation = require("./internal/useNavigation");
var _useResolvedLocaleOptions = require("./internal/useResolvedLocaleOptions");
var _useWeekDayLabels = require("./internal/useWeekDayLabels");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const useDatePicker = _ref => {
  let {
    onDateSelect,
    date: dateString,
    minDate,
    maxDate,
    format,
    strictValidation,
    options
  } = _ref;
  const optionsWithCustomerCalendar = (0, _react.useMemo)(() => {
    var _dhis2CalendarsMap, _options$calendar;
    const calendar = (0, _helpers.getCustomCalendarIfExists)((_dhis2CalendarsMap = _dhis2CalendarsMap2.dhis2CalendarsMap[(_options$calendar = options.calendar) !== null && _options$calendar !== void 0 ? _options$calendar : 'gregorian']) !== null && _dhis2CalendarsMap !== void 0 ? _dhis2CalendarsMap : options.calendar);
    return {
      ...options,
      calendar
    };
  }, [options]);
  const resolvedOptions = (0, _useResolvedLocaleOptions.useResolvedLocaleOptions)(optionsWithCustomerCalendar);
  const prevDateStringRef = (0, _react.useRef)(dateString);
  const todayZdt = (0, _react.useMemo)(() => (0, _index.getNowInCalendar)(resolvedOptions.calendar, resolvedOptions.timeZone).startOfDay(), [resolvedOptions]);
  const date = (0, _react.useMemo)(() => (0, _helpers.extractAndValidateDateString)(dateString, {
    ...resolvedOptions,
    minDateString: minDate,
    maxDateString: maxDate,
    strictValidation,
    format
  }), [minDate, maxDate, strictValidation, format, resolvedOptions, dateString]);
  date.format = !date.format ? format : date.format;
  const temporalCalendar = (0, _react.useMemo)(() => _polyfill.Temporal.Calendar.from(resolvedOptions.calendar), [resolvedOptions.calendar]);
  const temporalTimeZone = (0, _react.useMemo)(() => _polyfill.Temporal.TimeZone.from(resolvedOptions.timeZone), [resolvedOptions.timeZone]);
  const selectedDateZdt = dateString ? _polyfill.Temporal.Calendar.from(temporalCalendar).dateFromFields(date).toZonedDateTime({
    timeZone: temporalTimeZone
  }) : null;
  const [firstZdtOfVisibleMonth, setFirstZdtOfVisibleMonth] = (0, _react.useState)(() => {
    const zdt = selectedDateZdt || todayZdt;
    return zdt.with({
      day: 1
    });
  });
  const localeOptions = (0, _react.useMemo)(() => ({
    locale: resolvedOptions.locale,
    calendar: temporalCalendar,
    timeZone: temporalTimeZone,
    weekDayFormat: resolvedOptions.weekDayFormat,
    numberingSystem: resolvedOptions.numberingSystem
  }), [resolvedOptions, temporalCalendar, temporalTimeZone]);
  const weekDayLabels = (0, _useWeekDayLabels.useWeekDayLabels)(localeOptions);
  const navigation = (0, _useNavigation.useNavigation)(firstZdtOfVisibleMonth.withCalendar(localeOptions.calendar), setFirstZdtOfVisibleMonth, localeOptions);
  const selectDate = (0, _react.useCallback)(zdt => {
    onDateSelect({
      calendarDate: zdt,
      calendarDateString: (0, _helpers.formatDate)(zdt, undefined, date.format)
    });
  }, [onDateSelect, date.format]);
  const calendarWeekDaysZdts = (0, _useCalendarWeekDays.useCalendarWeekDays)(firstZdtOfVisibleMonth);
  (0, _react.useEffect)(() => {
    if (dateString === prevDateStringRef.current) {
      return;
    }
    prevDateStringRef.current = dateString;
    const zdt = _polyfill.Temporal.Calendar.from(temporalCalendar).dateFromFields(date).toZonedDateTime({
      timeZone: temporalTimeZone
    });
    if ((firstZdtOfVisibleMonth.year !== zdt.year || firstZdtOfVisibleMonth.month !== zdt.month) && !calendarWeekDaysZdts.some(week => week.some(day => day.equals(zdt)))) {
      setFirstZdtOfVisibleMonth(zdt.subtract({
        days: zdt.day - 1
      }));
    }
  }, [date, dateString, firstZdtOfVisibleMonth, calendarWeekDaysZdts, temporalCalendar, temporalTimeZone]);
  return {
    calendarWeekDays: calendarWeekDaysZdts.map(week => week.map(weekDayZdt => ({
      zdt: weekDayZdt,
      calendarDate: (0, _helpers.formatDate)(weekDayZdt, undefined, date.format),
      label: _localisationHelpers.default.localiseWeekLabel(weekDayZdt.withCalendar(localeOptions.calendar), localeOptions),
      onClick: () => selectDate(weekDayZdt),
      isSelected: selectedDateZdt ? selectedDateZdt === null || selectedDateZdt === void 0 ? void 0 : selectedDateZdt.withCalendar('iso8601').equals(weekDayZdt.withCalendar('iso8601')) : false,
      isToday: todayZdt && weekDayZdt.equals(todayZdt),
      isInCurrentMonth: firstZdtOfVisibleMonth && weekDayZdt.month === firstZdtOfVisibleMonth.month
    }))),
    ...navigation,
    weekDayLabels,
    isValid: date.isValid,
    warningMessage: date.warningMessage,
    errorMessage: date.errorMessage
  };
};
exports.useDatePicker = useDatePicker;