import i18n from '@dhis2/d2-i18n';
import { Temporal } from '@js-temporal/polyfill';
import { fromAnyDate, formatDate, padWithZeroes } from '../../utils/index';
import doesPeriodEndBefore from './does-period-end-before';
const Days = {
  Monday: 1,
  Tuesday: 2,
  Wednesday: 3,
  Thursday: 4,
  Friday: 5,
  Saturday: 6,
  Sunday: 7
};
// Does not need a `locale` as we're displaying the month as number in the
// displayName/name
const generateFixedPeriodsWeekly = _ref => {
  let {
    year,
    calendar,
    periodType,
    startingDay,
    endsBefore
  } = _ref;
  const startingDayToUse = getStartingDay(periodType, startingDay);
  let date = getStartingDate({
    year,
    calendar,
    periodType,
    startingDay: startingDayToUse
  });
  const days = [];
  let i = 1;
  const daysToAdd = periodType === 'BIWEEKLY' ? 13 : 6;
  do {
    const endofWeek = date.add({
      days: daysToAdd
    });
    if (endsBefore && doesPeriodEndBefore({
      period: {
        startDate: formatDate(date),
        endDate: formatDate(endofWeek)
      },
      date: endsBefore,
      calendar
    })) {
      break;
    }
    const value = buildValue({
      periodType,
      startingDay: startingDayToUse,
      year,
      weekIndex: i
    });
    if (!(endofWeek.year === year + 1 && endofWeek.day >= 4)) {
      const name = buildLabel({
        periodType,
        date,
        nextWeek: endofWeek,
        weekIndex: i
      });
      days.push({
        periodType,
        id: value,
        iso: value,
        name,
        displayName: name,
        startDate: formatDate(date),
        endDate: formatDate(endofWeek)
      });
    }
    date = fromAnyDate({
      date: endofWeek,
      calendar
    }).add({
      days: 1
    });
    i++;
  } while (date.year === year); // important to have the condition after since the very first day can be in the previous year
  return days;
};
const getStartingDay = (periodType, startingDay) => {
  switch (periodType) {
    case 'WEEKLYMON':
      return Days.Monday;
    case 'WEEKLYTUE':
      return Days.Tuesday;
    case 'WEEKLYWED':
      return Days.Wednesday;
    case 'WEEKLYTHU':
      return Days.Thursday;
    case 'WEEKLYFRI':
      return Days.Friday;
    case 'WEEKLYSAT':
      return Days.Saturday;
    case 'WEEKLYSUN':
      return Days.Sunday;
    case 'WEEKLY':
    case 'BIWEEKLY':
    default:
      return startingDay || Days.Monday;
  }
};
const getStartingDate = options => {
  const {
    year,
    calendar,
    startingDay
  } = options;

  // first week in every year has the 4th in the first month
  const fourthOfFirstMonth = Temporal.PlainDate.from({
    year,
    month: 1,
    day: 4,
    calendar
  });
  const dayDiff = fourthOfFirstMonth.dayOfWeek - startingDay;
  if (dayDiff > 0) {
    return fourthOfFirstMonth.subtract({
      days: dayDiff
    });
  } else if (dayDiff < 0) {
    return fourthOfFirstMonth.subtract({
      days: dayDiff + 7
    });
  }
  return fourthOfFirstMonth;
};
const DaysKeys = {
  1: '',
  // Monday is the default and has no key
  2: 'Tue',
  3: 'Wed',
  4: 'Thu',
  5: 'Fri',
  6: 'Sat',
  7: 'Sun'
};
const buildValue = _ref2 => {
  let {
    startingDay,
    periodType,
    year,
    weekIndex
  } = _ref2;
  const periodKey = periodType === 'BIWEEKLY' ? 'BiW' : 'W';
  return `${year}${DaysKeys[startingDay]}${periodKey}${weekIndex}`;
};
const buildLabel = _ref3 => {
  let {
    periodType,
    date,
    nextWeek,
    weekIndex
  } = _ref3;
  const {
    year,
    month,
    day
  } = date;
  const {
    year: nextYear,
    month: nextMonth,
    day: nextDay
  } = nextWeek;
  const prefix = periodType === 'BIWEEKLY' ? i18n.t('Bi-Week') : i18n.t('Week');
  const label = `${prefix} ${weekIndex} - ${year}-${padWithZeroes(month)}-${padWithZeroes(day)} - ${nextYear}-${padWithZeroes(nextMonth)}-${padWithZeroes(nextDay)}`;
  return label;
};
export default generateFixedPeriodsWeekly;