"use strict";

var _propTypes = _interopRequireDefault(require("prop-types"));

var _mutuallyExclusive = require("../mutuallyExclusive.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const toWarning = message => `Warning: Failed prop type: ${message}`;

describe('mutuallyExclusive', () => {
  jest.spyOn(console, 'error').mockImplementation(() => null);
  afterEach(() => console.error.mockClear());
  describe('Valid', () => {
    it('should work when only one mutually exclusive prop is provided', () => {
      const props = {
        foo: 42
      };
      const mutuallyExclusiveTypes = (0, _mutuallyExclusive.mutuallyExclusive)(['foo', 'bar', 'baz'], _propTypes.default.number);
      const types = {
        foo: mutuallyExclusiveTypes,
        bar: mutuallyExclusiveTypes,
        baz: mutuallyExclusiveTypes
      };

      _propTypes.default.checkPropTypes(types, props, 'foo', 'TestComponent');

      _propTypes.default.checkPropTypes(types, props, 'bar', 'TestComponent');

      _propTypes.default.checkPropTypes(types, props, 'baz', 'TestComponent');

      expect(console.error).toBeCalledTimes(0);
    });
  });
  describe('Invalid', () => {
    it('should fail when the provided type is wrong', () => {
      const props = {
        foo: 'string'
      };
      const types = {
        bar: (0, _mutuallyExclusive.mutuallyExclusive)(['foo', 'bar', 'baz'], _propTypes.default.number),
        foo: (0, _mutuallyExclusive.mutuallyExclusive)(['foo', 'bar', 'baz'], _propTypes.default.number),
        baz: (0, _mutuallyExclusive.mutuallyExclusive)(['foo', 'bar', 'baz'], _propTypes.default.number)
      };
      const errorMessage = toWarning('Invalid prop `foo` of type `string` supplied to `TestComponent`, expected `number`.');

      _propTypes.default.checkPropTypes(types, props, '____', 'TestComponent');

      expect(console.error).toBeCalledTimes(1);
      expect(console.error).toHaveBeenCalledWith(errorMessage);
    });
    it('should fail when multiple exclusive props are provided', () => {
      const props = {
        foo: 42,
        bar: 1337
      };
      const mutuallyExclusiveTypes = (0, _mutuallyExclusive.mutuallyExclusive)(['foo', 'bar', 'baz'], _propTypes.default.number);
      const types = {
        foo: mutuallyExclusiveTypes,
        bar: mutuallyExclusiveTypes,
        baz: mutuallyExclusiveTypes
      };
      const errorMessage1 = toWarning("Invalid prop `foo` supplied to `TestComponent`, Property 'foo' is mutually exclusive with 'bar', but both have a thruthy value.");
      const errorMessage2 = toWarning("Invalid prop `bar` supplied to `TestComponent`, Property 'bar' is mutually exclusive with 'foo', but both have a thruthy value.");

      _propTypes.default.checkPropTypes(types, props, 'prop', 'TestComponent');

      _propTypes.default.checkPropTypes(types, props, 'prop', 'TestComponent');

      _propTypes.default.checkPropTypes(types, props, 'prop', 'TestComponent');

      expect(console.error).toBeCalledTimes(2);
      expect(console.error).toHaveBeenNthCalledWith(1, errorMessage1);
      expect(console.error).toHaveBeenNthCalledWith(2, errorMessage2);
    });
  });
});