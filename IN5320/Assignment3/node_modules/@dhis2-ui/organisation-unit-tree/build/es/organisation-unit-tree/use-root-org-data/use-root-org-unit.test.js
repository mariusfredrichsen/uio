import { CustomDataProvider } from '@dhis2/app-runtime';
import { renderHook } from '@testing-library/react-hooks';
import React from 'react';
import { useRootOrgData } from './use-root-org-data.js';
describe('OrganisationUnitTree - useRootOrgData', () => {
  // @TODO: Figure out why this is necessary at all...
  const origError = console.error;
  jest.spyOn(console, 'error').mockImplementation(function () {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    const [err] = args;
    if (!err.toString().match(/^Warning: An update to/)) {
      origError(...args);
    }
  });

  // @TODO: This is kind of necessary; no idea if we can get rid of this
  const origWarn = console.warn;
  const dynamicQueryWarningMsg = "The query should be static, don't create it within the render loop!";
  jest.spyOn(console, 'warn').mockImplementation(function () {
    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }
    const [err] = args;
    if (!err.toString().match(dynamicQueryWarningMsg)) {
      origWarn(...args);
    }
  });
  afterAll(() => {
    console.error.mockRestore();
    console.warn.mockRestore();
  });
  const dataProviderData = {
    organisationUnits: jest.fn(() => {
      return {
        id: 'A0000000000',
        path: '/A0000000000',
        displayName: 'Org Unit 1'
      };
    })
  };
  const wrapper = _ref => {
    let {
      children
    } = _ref;
    return /*#__PURE__*/React.createElement(CustomDataProvider, {
      data: dataProviderData
    }, children);
  };
  it('should respond with `loading: false`, `error: null` and `data: null` initially', () => {
    const {
      result
    } = renderHook(() => useRootOrgData(['A0000000000']), {
      wrapper
    });
    expect(result.current).toEqual(expect.objectContaining({
      loading: true,
      error: null,
      data: null
    }));
    expect(result.current.refetch).toBeInstanceOf(Function);
  });
  it('should provide the org unit data', async () => {
    const {
      result,
      waitForNextUpdate
    } = renderHook(() => useRootOrgData(['A0000000000']), {
      wrapper
    });
    await waitForNextUpdate();
    expect(result.current).toEqual(expect.objectContaining({
      loading: false,
      error: null,
      data: {
        A0000000000: {
          id: 'A0000000000',
          path: '/A0000000000',
          displayName: 'Org Unit 1'
        }
      }
    }));
  });
  it('should provide the error', async () => {
    const errorWrapper = _ref2 => {
      let {
        children
      } = _ref2;
      return /*#__PURE__*/React.createElement(CustomDataProvider, {
        data: {
          organisationUnits: async () => {
            throw new Error('Error message');
          }
        }
      }, children);
    };
    const {
      result,
      waitForNextUpdate
    } = renderHook(() => useRootOrgData(['A0000000000']), {
      wrapper: errorWrapper
    });
    await waitForNextUpdate();
    expect(result.current).toEqual(expect.objectContaining({
      loading: false,
      error: new Error('Error message'),
      data: null
    }));
  });
  it('should send the "isUserDataViewFallback" parameter with value "undefined"', async () => {
    const {
      waitForNextUpdate
    } = renderHook(() => useRootOrgData(['A0000000000']), {
      wrapper
    });
    await waitForNextUpdate();
    expect(dataProviderData.organisationUnits).toHaveBeenCalledWith('read', expect.objectContaining({
      params: expect.objectContaining({
        isUserDataViewFallback: undefined
      })
    }), expect.objectContaining({}) // contains the `signal`
    );
  });
  it('should send the "isUserDataViewFallback" parameter with value "true"', async () => {
    const options = {
      isUserDataViewFallback: true
    };
    const {
      waitForNextUpdate
    } = renderHook(() => useRootOrgData(['A0000000000'], options), {
      wrapper
    });
    await waitForNextUpdate();
    expect(dataProviderData.organisationUnits).toHaveBeenCalledWith('read', expect.objectContaining({
      params: expect.objectContaining({
        isUserDataViewFallback: true
      })
    }), expect.objectContaining({}) // contains the `signal`
    );
  });
  it('should patch the display name if it is missing', async () => {
    const dataProviderDataWithoutDisplayName = {
      organisationUnits: jest.fn(() => {
        return {
          id: 'A0000000000',
          path: '/A0000000000'
        };
      })
    };
    const wrapperWithoutDisplayName = _ref3 => {
      let {
        children
      } = _ref3;
      return /*#__PURE__*/React.createElement(CustomDataProvider, {
        data: dataProviderDataWithoutDisplayName
      }, children);
    };
    const {
      result,
      waitForNextUpdate
    } = renderHook(() => useRootOrgData(['A0000000000']), {
      wrapper: wrapperWithoutDisplayName
    });
    await waitForNextUpdate();
    expect(result.current).toEqual(expect.objectContaining({
      loading: false,
      error: null,
      data: {
        A0000000000: {
          id: 'A0000000000',
          path: '/A0000000000',
          displayName: ''
        }
      }
    }));
  });
});