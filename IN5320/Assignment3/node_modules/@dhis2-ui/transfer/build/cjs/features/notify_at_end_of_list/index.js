"use strict";

var _cypressCucumberPreprocessor = require("@badeball/cypress-cucumber-preprocessor");
(0, _cypressCucumberPreprocessor.Given)('the Transfer has enough items to fill the source list completely', () => {
  cy.visitStory('Transfer End Of List', 'Full Source List');
  cy.wrap('source').as('listType');
});
(0, _cypressCucumberPreprocessor.Given)('the Transfer has enough items to fill the picked list completely', () => {
  cy.visitStory('Transfer End Of List', 'Full Picked List');
  cy.wrap('picked').as('listType');
});
(0, _cypressCucumberPreprocessor.Given)('the Transfer does not have enough items to fill the source list completely', () => {
  cy.visitStory('Transfer End Of List', 'Partial Source List');
  cy.wrap('source').as('listType');
});
(0, _cypressCucumberPreprocessor.Given)('the Transfer does not have enough items to fill the picked list completely', () => {
  cy.visitStory('Transfer End Of List', 'Partial Picked List');
  cy.wrap('picked').as('listType');
});
(0, _cypressCucumberPreprocessor.When)('the user scroll to the end of the list', () => {
  cy.get('@listType').then(listType => {
    const listSelector = listType === 'source' ? 'transfer-sourceoptions' : 'transfer-pickedoptions';
    cy.get(`{${listSelector}-endintersectiondetector}`).scrollIntoView();
  });
});
(0, _cypressCucumberPreprocessor.Then)('the callback for reaching the end should not be called', () => {
  cy.all(() => cy.window(), () => cy.get('@listType')).should(_ref => {
    let [win, listType] = _ref;
    const callback = listType === 'source' ? win.onEndReached : win.onEndReachedPicked;
    expect(callback).to.not.be.called;
  });
});
(0, _cypressCucumberPreprocessor.Then)('the callback for reaching the end should be called', () => {
  cy.all(() => cy.window(), () => cy.get('@listType')).should(_ref2 => {
    let [win, listType] = _ref2;
    const callback = listType === 'source' ? win.onEndReached : win.onEndReachedPicked;
    expect(callback).to.be.calledOnce;
  });
});