import { Temporal } from '@js-temporal/polyfill';
import { useCallback, useEffect, useMemo, useRef, useState } from 'react';
import { dhis2CalendarsMap } from '../constants/dhis2CalendarsMap';
import { getNowInCalendar } from '../index';
import { formatDate, getCustomCalendarIfExists, extractAndValidateDateString } from '../utils/helpers';
import localisationHelpers from '../utils/localisationHelpers';
import { useCalendarWeekDays } from './internal/useCalendarWeekDays';
import { useNavigation } from './internal/useNavigation';
import { useResolvedLocaleOptions } from './internal/useResolvedLocaleOptions';
import { useWeekDayLabels } from './internal/useWeekDayLabels';
export const useDatePicker = _ref => {
  let {
    onDateSelect,
    date: dateString,
    minDate,
    maxDate,
    format,
    strictValidation,
    options
  } = _ref;
  const optionsWithCustomerCalendar = useMemo(() => {
    var _dhis2CalendarsMap, _options$calendar;
    const calendar = getCustomCalendarIfExists((_dhis2CalendarsMap = dhis2CalendarsMap[(_options$calendar = options.calendar) !== null && _options$calendar !== void 0 ? _options$calendar : 'gregorian']) !== null && _dhis2CalendarsMap !== void 0 ? _dhis2CalendarsMap : options.calendar);
    return {
      ...options,
      calendar
    };
  }, [options]);
  const resolvedOptions = useResolvedLocaleOptions(optionsWithCustomerCalendar);
  const prevDateStringRef = useRef(dateString);
  const todayZdt = useMemo(() => getNowInCalendar(resolvedOptions.calendar, resolvedOptions.timeZone).startOfDay(), [resolvedOptions]);
  const date = useMemo(() => extractAndValidateDateString(dateString, {
    ...resolvedOptions,
    minDateString: minDate,
    maxDateString: maxDate,
    strictValidation,
    format
  }), [minDate, maxDate, strictValidation, format, resolvedOptions, dateString]);
  date.format = !date.format ? format : date.format;
  const temporalCalendar = useMemo(() => Temporal.Calendar.from(resolvedOptions.calendar), [resolvedOptions.calendar]);
  const temporalTimeZone = useMemo(() => Temporal.TimeZone.from(resolvedOptions.timeZone), [resolvedOptions.timeZone]);
  const selectedDateZdt = dateString ? Temporal.Calendar.from(temporalCalendar).dateFromFields(date).toZonedDateTime({
    timeZone: temporalTimeZone
  }) : null;
  const [firstZdtOfVisibleMonth, setFirstZdtOfVisibleMonth] = useState(() => {
    const zdt = selectedDateZdt || todayZdt;
    return zdt.with({
      day: 1
    });
  });
  const localeOptions = useMemo(() => ({
    locale: resolvedOptions.locale,
    calendar: temporalCalendar,
    timeZone: temporalTimeZone,
    weekDayFormat: resolvedOptions.weekDayFormat,
    numberingSystem: resolvedOptions.numberingSystem
  }), [resolvedOptions, temporalCalendar, temporalTimeZone]);
  const weekDayLabels = useWeekDayLabels(localeOptions);
  const navigation = useNavigation(firstZdtOfVisibleMonth.withCalendar(localeOptions.calendar), setFirstZdtOfVisibleMonth, localeOptions);
  const selectDate = useCallback(zdt => {
    onDateSelect({
      calendarDate: zdt,
      calendarDateString: formatDate(zdt, undefined, date.format)
    });
  }, [onDateSelect, date.format]);
  const calendarWeekDaysZdts = useCalendarWeekDays(firstZdtOfVisibleMonth);
  useEffect(() => {
    if (dateString === prevDateStringRef.current) {
      return;
    }
    prevDateStringRef.current = dateString;
    const zdt = Temporal.Calendar.from(temporalCalendar).dateFromFields(date).toZonedDateTime({
      timeZone: temporalTimeZone
    });
    if ((firstZdtOfVisibleMonth.year !== zdt.year || firstZdtOfVisibleMonth.month !== zdt.month) && !calendarWeekDaysZdts.some(week => week.some(day => day.equals(zdt)))) {
      setFirstZdtOfVisibleMonth(zdt.subtract({
        days: zdt.day - 1
      }));
    }
  }, [date, dateString, firstZdtOfVisibleMonth, calendarWeekDaysZdts, temporalCalendar, temporalTimeZone]);
  return {
    calendarWeekDays: calendarWeekDaysZdts.map(week => week.map(weekDayZdt => ({
      zdt: weekDayZdt,
      calendarDate: formatDate(weekDayZdt, undefined, date.format),
      label: localisationHelpers.localiseWeekLabel(weekDayZdt.withCalendar(localeOptions.calendar), localeOptions),
      onClick: () => selectDate(weekDayZdt),
      isSelected: selectedDateZdt ? selectedDateZdt === null || selectedDateZdt === void 0 ? void 0 : selectedDateZdt.withCalendar('iso8601').equals(weekDayZdt.withCalendar('iso8601')) : false,
      isToday: todayZdt && weekDayZdt.equals(todayZdt),
      isInCurrentMonth: firstZdtOfVisibleMonth && weekDayZdt.month === firstZdtOfVisibleMonth.month
    }))),
    ...navigation,
    weekDayLabels,
    isValid: date.isValid,
    warningMessage: date.warningMessage,
    errorMessage: date.errorMessage
  };
};