"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _polyfill = require("@js-temporal/polyfill");
var _helpers = require("../../utils/helpers");
var _index = require("../../utils/index");
var _getStartingMonthForPeriodType = require("../get-starting-month-for-period-type");
var _monthNumbers = _interopRequireDefault(require("../month-numbers"));
var _index2 = require("../monthly-periods/index");
var _periodTypeGroups = require("../period-type-groups");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const buildMonthlyFixedPeriod = _ref => {
  let {
    periodType,
    month,
    year: yearArg,
    calendar,
    locale
  } = _ref;
  const index = (0, _index2.computeMonthlyPeriodIndex)({
    periodType,
    month: month.month,
    monthsInYear: month.monthsInYear
  });
  const monthToAdd = getMonthsToAdd(periodType);
  const nextMonth = month.add({
    months: monthToAdd
  });
  const id = buildId({
    periodType,
    currentMonth: month,
    year: yearArg,
    index
  });
  if (month.calendar === 'ethiopic') {
    // @TODO(jira): Create issue
    // @TODO: Confirm the special cases for the 13th month with Abyot, then
    // update the start/end dates for Ethiopic calendar'
    console.warn('todo: confirm the special cases for the 13th month with Abyot, then update the start/end dates for Ethiopic calendar');
  }
  const endDate = _polyfill.Temporal.PlainDate.from({
    year: nextMonth.year,
    month: nextMonth.month,
    day: 1,
    calendar: nextMonth.calendar
  }).subtract({
    days: 1
  });
  const name = buildLabel({
    periodType,
    month,
    locale,
    calendar,
    nextMonth: nextMonth.subtract({
      months: 1
    }),
    // when we display, we want to show the range using previous month
    index
  });
  return {
    periodType,
    id,
    iso: id,
    name,
    displayName: name,
    startDate: (0, _helpers.formatDate)(month, 'startOfMonth'),
    endDate: (0, _helpers.formatDate)(endDate, 'endOfMonth')
  };
};
var _default = buildMonthlyFixedPeriod;
exports.default = _default;
const buildId = _ref2 => {
  let {
    periodType,
    currentMonth,
    year,
    index
  } = _ref2;
  if (periodType === 'BIMONTHLY') {
    return `${year}${(0, _helpers.padWithZeroes)(index)}B`;
  }
  if (periodType === 'QUARTERLY') {
    return `${year}Q${index}`;
  }
  if (periodType === 'SIXMONTHLY') {
    return `${year}S${index}`;
  }
  if (_periodTypeGroups.quarterlyFixedPeriodTypes.includes(periodType)) {
    const month = _monthNumbers.default[(0, _getStartingMonthForPeriodType.getStartingMonthByPeriodType)(periodType)].name;
    return `${year}${month}Q${index}`;
  }
  if (_periodTypeGroups.sixmonthlyFixedPeriodTypes.includes(periodType)) {
    const month = _monthNumbers.default[(0, _getStartingMonthForPeriodType.getStartingMonthByPeriodType)(periodType)].name;
    return `${year}${month}S${index}`;
  }
  return `${year}${(0, _helpers.padWithZeroes)(currentMonth.month)}`;
};
const getMonthsToAdd = periodType => {
  if (_periodTypeGroups.sixmonthlyFixedPeriodTypes.includes(periodType)) {
    return 6;
  }
  if (_periodTypeGroups.quarterlyFixedPeriodTypes.includes(periodType)) {
    return 3;
  }
  if (periodType === 'MONTHLY') {
    return 1;
  }
  if (periodType === 'BIMONTHLY') {
    return 2;
  }
  throw new Error(`unrecognised monthly period type ${periodType}`);
};
const buildLabel = options => {
  const {
    periodType,
    month,
    nextMonth,
    calendar,
    locale
  } = options;
  if ((0, _helpers.isCustomCalendar)(calendar)) {
    return buildLabelForCustomCalendar(options);
  }
  const withYearFormat = {
    month: 'long',
    year: 'numeric',
    calendar
  };
  const monthOnlyFormat = {
    month: 'long',
    calendar
  };
  let result = '';
  if (_periodTypeGroups.multiMonthFixedPeriodTypes.includes(periodType)) {
    const format = month.year === nextMonth.year ? monthOnlyFormat : withYearFormat;
    result = `${month.toLocaleString(locale, format)} - ${nextMonth.toLocaleString(locale, withYearFormat)}`;
  } else {
    result = `${month.toLocaleString(locale, withYearFormat)}`;
  }

  // needed for ethiopic calendar - the default formatter adds the era, which is not what we want in DHIS2
  result = result.replace(/ERA\d+\s*/g, '').trim();
  return result;
};
const buildLabelForCustomCalendar = _ref3 => {
  let {
    periodType,
    month,
    nextMonth,
    calendar,
    locale
  } = _ref3;
  let result = '';
  if (_periodTypeGroups.multiMonthFixedPeriodTypes.includes(periodType)) {
    const showYear = month.year !== nextMonth.year;
    result = `${_index.localisationHelpers.localiseMonth(month, {
      locale,
      calendar
    }, {})}${showYear ? ` ${month.year}` : ''} - ${_index.localisationHelpers.localiseMonth(nextMonth, {
      locale,
      calendar
    }, {})} ${nextMonth.year}`;
  } else {
    result = `${_index.localisationHelpers.localiseMonth(month, {
      locale,
      calendar
    }, {})} ${nextMonth.year}`;
  }
  return result;
};