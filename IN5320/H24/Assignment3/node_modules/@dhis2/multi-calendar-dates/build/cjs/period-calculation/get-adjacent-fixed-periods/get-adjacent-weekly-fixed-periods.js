"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _polyfill = require("@js-temporal/polyfill");
var _index = require("../../utils/index");
var _index2 = require("../generate-fixed-periods/index");
const getAdjacentWeeklyFixedPeriods = args => {
  const {
    steps: stepsInput
  } = args;
  const steps = Math.abs(stepsInput);
  return stepsInput > 0 ? getFollowingWeeklyFixedPeriods({
    ...args,
    steps
  }) : getPreviousWeeklyFixedPeriods({
    ...args,
    steps
  });
};
var _default = getAdjacentWeeklyFixedPeriods;
exports.default = _default;
const getFollowingWeeklyFixedPeriods = _ref => {
  let {
    period,
    steps,
    calendar
  } = _ref;
  // We need to get the year this way, can't use period.startDate as that
  // might be in the previous year (Week 1), can't use period.endDate as that
  // might be in the next year (Week 52/53)
  const startYear = parseInt(period.id.substring(0, 4), 10);
  const startDate = (0, _index.fromAnyDate)({
    date: period.startDate,
    calendar
  });
  const followingPeriods = [];
  let curYear = startYear;
  while (followingPeriods.length < steps) {
    const periodsForYear = (0, _index2.generateFixedPeriodsWeekly)({
      year: curYear,
      calendar: calendar,
      periodType: period.periodType,
      startingDay: 1
    });
    const index = curYear === startYear ? periodsForYear.findIndex(curPeriod => {
      const curStartDate = (0, _index.fromAnyDate)({
        calendar,
        date: curPeriod.startDate
      });
      return _polyfill.Temporal.PlainDate.compare(startDate, curStartDate) === -1;
    }) : 0;
    const nextCount = steps - followingPeriods.length;
    const nextPeriods = periodsForYear.slice(index, index + nextCount);
    followingPeriods.push(...nextPeriods);
    curYear++;
  }
  return followingPeriods;
};
const getPreviousWeeklyFixedPeriods = _ref2 => {
  let {
    period,
    steps,
    calendar
  } = _ref2;
  const startDate = (0, _index.fromAnyDate)({
    date: period.startDate,
    calendar
  });
  const previousPeriods = [];
  let curYear = startDate.year;
  while (previousPeriods.length < steps) {
    const nextCount = steps - previousPeriods.length;
    const periodsForYear = (0, _index2.generateFixedPeriodsWeekly)({
      year: curYear,
      calendar: calendar,
      periodType: period.periodType,
      startingDay: 1
    });
    if (curYear < startDate.year) {
      const startIndex = Math.max(0, periodsForYear.length - nextCount);
      const prevPeriods = periodsForYear.slice(startIndex);
      previousPeriods.unshift(...prevPeriods);
      curYear--;
      continue;
    }
    const foundIndex = periodsForYear.findIndex(curPeriod => {
      const curStartDate = (0, _index.fromAnyDate)({
        calendar,
        date: curPeriod.startDate
      });
      const startDateIsLowerThanCurStartDate = _polyfill.Temporal.PlainDate.compare(startDate, curStartDate) === -1;
      return startDateIsLowerThanCurStartDate;
    });
    const endIndex = foundIndex !== -1 ?
    // have to remove 1 to exclude the current one
    foundIndex - 1 :
    // This is the case when the "startDate" is the first day of the
    // first period of the next year
    periodsForYear.length;
    const startIndex = Math.max(0, endIndex - nextCount);
    const prevPeriods = periodsForYear.slice(startIndex, endIndex);
    previousPeriods.push(...prevPeriods);
    curYear--;
  }
  return previousPeriods;
};