function _extends() { return _extends = Object.assign ? Object.assign.bind() : function (n) { for (var e = 1; e < arguments.length; e++) { var t = arguments[e]; for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]); } return n; }, _extends.apply(null, arguments); }
/* eslint-disable react/prop-types */
import { mount } from 'enzyme';
import React from 'react';
import { StackedTableBody } from './stacked-table-body.js';
import { StackedTableCellHead } from './stacked-table-cell-head.js';
import { StackedTableCell } from './stacked-table-cell.js';
import { StackedTableHead } from './stacked-table-head.js';
import { StackedTableRowHead } from './stacked-table-row-head.js';
import { StackedTableRow } from './stacked-table-row.js';
import { StackedTable } from './stacked-table.js';
const Table = _ref => {
  let {
    headerLabels,
    bodyLabels
  } = _ref;
  return /*#__PURE__*/React.createElement(StackedTable, null, /*#__PURE__*/React.createElement(StackedTableHead, null, /*#__PURE__*/React.createElement(StackedTableRowHead, null, headerLabels.map((_ref2, index) => {
    let {
      label,
      ...props
    } = _ref2;
    return /*#__PURE__*/React.createElement(StackedTableCellHead, _extends({}, props, {
      key: label + index
    }), label);
  }))), /*#__PURE__*/React.createElement(StackedTableBody, null, /*#__PURE__*/React.createElement(StackedTableRow, null, bodyLabels.map(_ref3 => {
    let {
      label,
      ...props
    } = _ref3;
    return /*#__PURE__*/React.createElement(StackedTableCell, _extends({}, props, {
      key: label
    }), label);
  }))));
};
describe('StackedTable', () => {
  const headerLabels = [{
    label: 'First name',
    colSpan: '1'
  }, {
    label: 'Last name',
    colSpan: '1'
  }, {
    label: 'Incident date',
    colSpan: '1'
  }, {
    label: 'Last updated',
    colSpan: '1'
  }, {
    label: 'Age',
    colSpan: '1'
  }, {
    label: 'Registering unit',
    colSpan: '1'
  }, {
    label: 'Assigned user',
    colSpan: '1'
  }, {
    label: 'Status',
    colSpan: '1'
  }];
  const bodyLabels = [{
    label: 'Onyekachukwu'
  }, {
    label: 'Kariuki'
  }, {
    label: '02/06/2007'
  }, {
    label: '05/25/1972'
  }, {
    label: '66'
  }, {
    label: 'Jawi'
  }, {
    label: 'Sofie Hubert'
  }, {
    label: 'Incomplete'
  }];
  it('should add the headerLabels to each cell', () => {
    const table = mount( /*#__PURE__*/React.createElement(Table, {
      headerLabels: headerLabels,
      bodyLabels: bodyLabels
    }));
    const cells = table.find('td');
    headerLabels.forEach((label, index) => {
      const cell = cells.at(index);
      const title = cell.find('.title').text();
      expect(title).toBe(headerLabels[index].label);
    });
  });
  it('should not add empty header labels to the body cells', () => {
    const emptyLabelIndex = 2;
    const headerLabelsWithEmpty = [...headerLabels.slice(0, emptyLabelIndex), '', ...headerLabels.slice(emptyLabelIndex + 1)];
    const table = mount( /*#__PURE__*/React.createElement(Table, {
      headerLabels: headerLabelsWithEmpty,
      bodyLabels: bodyLabels
    }));
    const cells = table.find('td');
    const cell = cells.at(emptyLabelIndex);
    const title = cell.find('.title');
    expect(title).toHaveLength(0);
  });
  it('should add a header label with a colspan higher than 1 to multiple body cells', () => {
    const indexWithColspan = 1;
    const colSpan = 3;
    const originalHeaderLabel = headerLabels[indexWithColspan];
    const headerLabelsWithColspan = [...headerLabels.slice(0, indexWithColspan), {
      ...originalHeaderLabel,
      colSpan: `${colSpan}`
    }, ...headerLabels.slice(indexWithColspan + colSpan)];
    const table = mount( /*#__PURE__*/React.createElement(Table, {
      headerLabels: headerLabelsWithColspan,
      bodyLabels: bodyLabels
    }));
    const cells = table.find('td');
    const label = headerLabelsWithColspan[indexWithColspan].label;

    // all body cells that are group under the single header should share the same label
    for (let i = 0; i < colSpan; ++i) {
      const index = indexWithColspan + i;
      const cell = cells.at(index);
      expect(cell).toHaveLength(1);
      const title = cell.find('.title');
      expect(title.text()).toBe(label);
    }

    // the next body cell should have the label of the next header cell
    const titleAfterColspan = headerLabelsWithColspan[indexWithColspan + 1].label;
    const cellAfterColspan = cells.at(indexWithColspan + colSpan);
    expect(cellAfterColspan).toHaveLength(1);
    expect(cellAfterColspan.find('.title').text()).toBe(titleAfterColspan);
  });
});