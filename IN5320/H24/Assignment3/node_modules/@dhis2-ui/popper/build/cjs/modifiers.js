"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.resizeObserver = exports.getBaseModifiers = exports.deduplicateModifiers = void 0;
var _resizeObserverPolyfill = _interopRequireDefault(require("resize-observer-polyfill"));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
const attachResizeObservers = _ref => {
  let {
    state: {
      elements
    },
    options,
    instance: {
      update
    }
  } = _ref;
  const observers = Object.keys(options).reduce((acc, elementKey) => {
    if (options[elementKey]) {
      const observer = new _resizeObserverPolyfill.default(update);
      observer.observe(elements[elementKey]);
      acc.push(observer);
    }
    return acc;
  }, []);
  return () => {
    observers.forEach(observer => {
      observer.disconnect();
    });
  };
};
const getBaseModifiers = _ref2 => {
  let {
    observePopperResize,
    observeReferenceResize
  } = _ref2;
  return [{
    name: 'preventOverflow',
    options: {
      altAxis: true,
      rootBoundary: 'document',
      boundary: document.body
    }
  }, {
    name: 'flip',
    options: {
      rootBoundary: 'document',
      boundary: document.body
    }
  }, {
    name: 'resizeObserver',
    enabled: true,
    phase: 'write',
    fn: () => {},
    effect: attachResizeObservers,
    options: {
      popper: observePopperResize,
      reference: observeReferenceResize
    }
  }];
};
exports.getBaseModifiers = getBaseModifiers;
const deduplicateModifiers = (modifiers, resizeObservers) => {
  // Deduplicate modifiers from props and baseModifiers,
  // when duplicates are encountered (by name), use the
  // modifier from props so each Popper can be fully custom
  return getBaseModifiers(resizeObservers).filter(_ref3 => {
    let {
      name
    } = _ref3;
    return !modifiers.some(m => m.name === name);
  }).concat(modifiers);
};
exports.deduplicateModifiers = deduplicateModifiers;
const resizeObserver = exports.resizeObserver = {
  name: 'resizeObserver',
  enabled: true,
  phase: 'write',
  fn: () => {},
  effect: _ref4 => {
    let {
      state: {
        elements
      },
      options,
      instance: {
        update
      }
    } = _ref4;
    const observers = Object.keys(options).reduce((acc, elementKey) => {
      if (options[elementKey]) {
        const observer = new _resizeObserverPolyfill.default(update);
        observer.observe(elements[elementKey]);
        acc.push(observer);
      }
      return acc;
    }, []);
    return () => {
      observers.forEach(observer => {
        observer.disconnect();
      });
    };
  }
};