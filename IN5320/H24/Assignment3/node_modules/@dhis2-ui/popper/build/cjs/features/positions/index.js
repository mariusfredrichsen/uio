"use strict";

var _cypressCucumberPreprocessor = require("@badeball/cypress-cucumber-preprocessor");
// Visit stories with different placements
(0, _cypressCucumberPreprocessor.Given)('the Popper is rendered with placement top', () => {
  cy.visitStory('Popper', 'top');
});
(0, _cypressCucumberPreprocessor.Given)('the Popper is rendered with placement top-start', () => {
  cy.visitStory('Popper', 'top-start');
});
(0, _cypressCucumberPreprocessor.Given)('the Popper is rendered with placement top-end', () => {
  cy.visitStory('Popper', 'top-end');
});
(0, _cypressCucumberPreprocessor.Given)('the Popper is rendered with placement right', () => {
  cy.visitStory('Popper', 'right');
});
(0, _cypressCucumberPreprocessor.Given)('the Popper is rendered with placement right-start', () => {
  cy.visitStory('Popper', 'right-start');
});
(0, _cypressCucumberPreprocessor.Given)('the Popper is rendered with placement right-end', () => {
  cy.visitStory('Popper', 'right-end');
});
(0, _cypressCucumberPreprocessor.Given)('the Popper is rendered with placement bottom', () => {
  cy.visitStory('Popper', 'bottom');
});
(0, _cypressCucumberPreprocessor.Given)('the Popper is rendered with placement bottom-start', () => {
  cy.visitStory('Popper', 'bottom-start');
});
(0, _cypressCucumberPreprocessor.Given)('the Popper is rendered with placement bottom-end', () => {
  cy.visitStory('Popper', 'bottom-end');
});
(0, _cypressCucumberPreprocessor.Given)('the Popper is rendered with placement left', () => {
  cy.visitStory('Popper', 'left');
});
(0, _cypressCucumberPreprocessor.Given)('the Popper is rendered with placement left-start', () => {
  cy.visitStory('Popper', 'left-start');
});
(0, _cypressCucumberPreprocessor.Given)('the Popper is rendered with placement left-end', () => {
  cy.visitStory('Popper', 'left-end');
});

// Directional assertions
// top
(0, _cypressCucumberPreprocessor.Then)('the bottom of the popper is adjacent to the top of the reference element', () => {
  getRefAndPopperPositions().should(_ref => {
    let [refPos, popperPos] = _ref;
    expect(refPos.top).to.equal(popperPos.bottom);
  });
});
// right
(0, _cypressCucumberPreprocessor.Then)('the left of the popper is adjacent to the right of the reference element', () => {
  getRefAndPopperPositions().should(_ref2 => {
    let [refPos, popperPos] = _ref2;
    expect(refPos.right).to.equal(popperPos.left);
  });
});
// bottom
(0, _cypressCucumberPreprocessor.Then)('the top of the popper is adjacent to the bottom of the reference element', () => {
  getRefAndPopperPositions().should(_ref3 => {
    let [refPos, popperPos] = _ref3;
    expect(refPos.bottom).to.equal(popperPos.top);
  });
});
// left
(0, _cypressCucumberPreprocessor.Then)('the right of the popper is adjacent to the left of the reference element', () => {
  getRefAndPopperPositions().should(_ref4 => {
    let [refPos, popperPos] = _ref4;
    expect(refPos.left).to.equal(popperPos.right);
  });
});

// Horizontal alignments
// *-start
(0, _cypressCucumberPreprocessor.Then)('it is horizontally left aligned with the reference element', () => {
  getRefAndPopperPositions().should(_ref5 => {
    let [refPos, popperPos] = _ref5;
    expect(refPos.left).to.equal(popperPos.left);
  });
});
// * (no suffix)
(0, _cypressCucumberPreprocessor.Then)('it is horizontally center aligned with the reference element', () => {
  getRefAndPopperPositions().should(_ref6 => {
    let [refPos, popperPos] = _ref6;
    const refCenterX = refPos.left + refPos.width / 2;
    const popperCenterX = popperPos.left + popperPos.width / 2;
    expect(refCenterX).to.equal(popperCenterX);
  });
});
// *-end
(0, _cypressCucumberPreprocessor.Then)('it is horizontally right aligned with the reference element', () => {
  getRefAndPopperPositions().should(_ref7 => {
    let [refPos, popperPos] = _ref7;
    expect(refPos.right).to.equal(popperPos.right);
  });
});

// Vertical alignments
// *-start
(0, _cypressCucumberPreprocessor.Then)('it is vertically top aligned with the reference element', () => {
  getRefAndPopperPositions().should(_ref8 => {
    let [refPos, popperPos] = _ref8;
    expect(refPos.top).to.equal(popperPos.top);
  });
});
// * (no suffix)
(0, _cypressCucumberPreprocessor.Then)('it is vertically center aligned with the reference element', () => {
  getRefAndPopperPositions().should(_ref9 => {
    let [refPos, popperPos] = _ref9;
    const refCenterY = refPos.top + refPos.height / 2;
    const popperCenterY = popperPos.top + popperPos.height / 2;
    expect(refCenterY).to.equal(popperCenterY);
  });
});
// *-end
(0, _cypressCucumberPreprocessor.Then)('it is vertically bottom aligned with the reference element', () => {
  getRefAndPopperPositions().should(_ref10 => {
    let [refPos, popperPos] = _ref10;
    expect(refPos.bottom).to.equal(popperPos.bottom);
  });
});

// helper
function getRefAndPopperPositions() {
  return cy.getPositionsBySelectors('.reference-element', '[data-test="dhis2-uicore-popper"]');
}