"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SharingAutocomplete = void 0;
var _appRuntime = require("@dhis2/app-runtime");
var _propTypes = _interopRequireDefault(require("prop-types"));
var _react = _interopRequireWildcard(require("react"));
var _index = require("../helpers/index.js");
var _index2 = _interopRequireDefault(require("../locales/index.js"));
var _autocomplete = require("./autocomplete.js");
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
const query = {
  search: {
    resource: 'sharing/search',
    params: _ref => {
      let {
        search
      } = _ref;
      return {
        key: search
      };
    }
  }
};
const SharingAutocomplete = _ref2 => {
  var _data$search, _data$search2;
  let {
    selected,
    onSelection
  } = _ref2;
  const [search, setSearch] = (0, _react.useState)('');
  const [showResults, setShowResults] = (0, _react.useState)(false);
  const {
    data,
    refetch,
    fetching
  } = (0, _appRuntime.useDataQuery)(query, {
    lazy: true,
    onComplete: () => setShowResults(true)
  });

  /**
   * Ensure that local state doesn't get out of sync with the parent. On selection
   * this syncs the displayName of the parent selection to the local input state.
   */

  (0, _react.useEffect)(() => setSearch(selected), [selected]);

  /**
   * If the search string changes and is truthy, send out a request, otherwise
   * clear the selection.
   */

  const debouncedRefetch = (0, _react.useCallback)((0, _index.debounce)(refetch, 250), [refetch]);
  (0, _react.useEffect)(() => {
    if (search && search === selected) {
      return;
    }
    if (search) {
      debouncedRefetch({
        search
      });
    } else {
      onSelection(null);
      setShowResults(false);
    }
  }, [search]);

  // Concatenate all the results
  let results = [];
  if (data !== null && data !== void 0 && (_data$search = data.search) !== null && _data$search !== void 0 && _data$search.users) {
    const mapped = data.search.users.map(user => ({
      ...user,
      type: 'user'
    }));
    results = results.concat(mapped);
  }
  if (data !== null && data !== void 0 && (_data$search2 = data.search) !== null && _data$search2 !== void 0 && _data$search2.userGroups) {
    const mapped = data.search.userGroups.map(group => ({
      ...group,
      type: 'group'
    }));
    results = results.concat(mapped);
  }
  return /*#__PURE__*/_react.default.createElement(_autocomplete.Autocomplete, {
    inputWidth: "400px",
    label: _index2.default.t('User or group'),
    loading: fetching,
    placeholder: _index2.default.t('Search'),
    search: search,
    searchResults: showResults ? results : [],
    onClose: () => setShowResults(false),
    onSearch: setSearch,
    onSelect: id => {
      onSelection(results.find(result => result.id === id));
      setShowResults(false);
    }
  });
};
exports.SharingAutocomplete = SharingAutocomplete;
SharingAutocomplete.propTypes = {
  onSelection: _propTypes.default.func.isRequired,
  selected: _propTypes.default.string
};