"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.replaceAccessWithConstant = exports.isRemovableTarget = exports.debounce = exports.createOnRemovePayload = exports.createOnChangePayload = exports.createOnAddPayload = exports.convertConstantToAccess = exports.convertAccessToConstant = void 0;
var _constants = require("../constants.js");
var _this = void 0;
/**
 * Returns a function, that, as long as it continues to be invoked, will not be triggered. The
 * function will be called after it stops being called for N milliseconds. If `immediate` is
 * passed, trigger the function on the leading edge, instead of the trailing.
 */

const debounce = (func, wait, immediate) => {
  let timeout;
  return function () {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    const context = _this;
    const later = () => {
      timeout = null;
      if (!immediate) {
        func.apply(context, args);
      }
    };
    const callNow = immediate && !timeout;
    clearTimeout(timeout);
    timeout = setTimeout(later, wait);
    if (callNow) {
      func.apply(context, args);
    }
  };
};

/**
 * Access and constant conversion
 */
exports.debounce = debounce;
const convertAccessToConstant = access => {
  if (access === undefined) {
    return _constants.ACCESS_NONE;
  }
  if (typeof access === 'boolean') {
    return access ? _constants.ACCESS_VIEW_ONLY : _constants.ACCESS_NONE;
  }
  if (access.startsWith('rw')) {
    return _constants.ACCESS_VIEW_AND_EDIT;
  } else if (access.startsWith('r-')) {
    return _constants.ACCESS_VIEW_ONLY;
  } else {
    return _constants.ACCESS_NONE;
  }
};
exports.convertAccessToConstant = convertAccessToConstant;
const convertConstantToAccess = (constant, useBoolean) => {
  switch (constant) {
    case _constants.ACCESS_NONE:
      return useBoolean ? false : '--------';
    case _constants.ACCESS_VIEW_ONLY:
      return useBoolean ? true : 'r-------';
    case _constants.ACCESS_VIEW_AND_EDIT:
      return useBoolean ? true : 'rw------';
    default:
      return useBoolean ? false : '--------';
  }
};

/**
 * Replaces access property with constants used internally
 */
exports.convertConstantToAccess = convertConstantToAccess;
const replaceAccessWithConstant = _ref => {
  let {
    access,
    ...rest
  } = _ref;
  return {
    ...rest,
    access: convertAccessToConstant(access)
  };
};

/**
 * Helper to check whether to allow removing for the selected target
 */
exports.replaceAccessWithConstant = replaceAccessWithConstant;
const permanentTargets = [_constants.SHARE_TARGET_EXTERNAL, _constants.SHARE_TARGET_PUBLIC];
const isRemovableTarget = target => {
  // Do not allow removal of permanent targets
  return !permanentTargets.includes(target);
};

/**
 * Mutation payload creators
 */
exports.isRemovableTarget = isRemovableTarget;
const createOnChangePayload = _ref2 => {
  let {
    object,
    type,
    access,
    id
  } = _ref2;
  switch (type) {
    case 'public':
      {
        const data = {
          object: {
            ...object,
            publicAccess: convertConstantToAccess(access)
          }
        };
        return data;
      }
    case 'group':
      {
        const userGroupAccesses = object.userGroupAccesses.map(group => {
          if (group.id !== id) {
            return group;
          }
          return {
            ...group,
            access: convertConstantToAccess(access)
          };
        });
        const data = {
          object: {
            ...object,
            userGroupAccesses
          }
        };
        return data;
      }
    case 'user':
      {
        const userAccesses = object.userAccesses.map(user => {
          if (user.id !== id) {
            return user;
          }
          return {
            ...user,
            access: convertConstantToAccess(access)
          };
        });
        const data = {
          object: {
            ...object,
            userAccesses
          }
        };
        return data;
      }
  }
};
exports.createOnChangePayload = createOnChangePayload;
const createOnAddPayload = _ref3 => {
  let {
    object,
    type,
    id,
    access,
    name
  } = _ref3;
  switch (type) {
    case 'group':
      {
        const data = {
          object: {
            ...object,
            userGroupAccesses: [...object.userGroupAccesses, {
              id,
              name,
              access: convertConstantToAccess(access)
            }]
          }
        };
        return data;
      }
    case 'user':
      {
        const data = {
          object: {
            ...object,
            userAccesses: [...object.userAccesses, {
              id,
              name,
              access: convertConstantToAccess(access)
            }]
          }
        };
        return data;
      }
  }
};
exports.createOnAddPayload = createOnAddPayload;
const createOnRemovePayload = _ref4 => {
  let {
    object,
    type,
    id
  } = _ref4;
  switch (type) {
    case 'group':
      {
        const userGroupAccesses = object.userGroupAccesses.filter(group => group.id !== id);
        const data = {
          object: {
            ...object,
            userGroupAccesses
          }
        };
        return data;
      }
    case 'user':
      {
        const userAccesses = object.userAccesses.filter(user => user.id !== id);
        const data = {
          object: {
            ...object,
            userAccesses
          }
        };
        return data;
      }
  }
};
exports.createOnRemovePayload = createOnRemovePayload;