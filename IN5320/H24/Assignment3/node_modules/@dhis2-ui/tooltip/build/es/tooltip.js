import _JSXStyle from "styled-jsx/style";
import { colors, layers } from '@dhis2/ui-constants';
import { Popper } from '@dhis2-ui/popper';
import { Portal } from '@dhis2-ui/portal';
import PropTypes from 'prop-types';
import React, { useEffect, useRef, useState } from 'react';
const TOOLTIP_OFFSET = 4;
const popperStyle = {
  styles: /*#__PURE__*/React.createElement(_JSXStyle, {
    id: "1892168270"
  }, [`.jsx-1892168270{z-index:${layers.applicationTop};}`, "div[data-popper-reference-hidden=\"true\"].jsx-1892168270{visibility:hidden;}"]),
  className: "jsx-1892168270"
};
const offsetModifier = {
  name: 'offset',
  options: {
    offset: [0, TOOLTIP_OFFSET]
  }
};

/**
 * For some reason the intended effects of the 'hide' modifier work with or
 * without adding it to the popper... but it may be safe to include it anyway
 */
const hideModifier = {
  name: 'hide'
};
const flipModifier = {
  name: 'flip',
  options: {
    altBoundary: true
  }
};
const Tooltip = _ref => {
  let {
    children,
    className,
    closeDelay = 200,
    content,
    dataTest = 'dhis2-uicore-tooltip',
    maxWidth = 300,
    openDelay = 200,
    placement = 'top'
  } = _ref;
  const [open, setOpen] = useState(false);
  const popperReference = useRef();
  const openTimerRef = useRef(null);
  const closeTimerRef = useRef(null);
  const onMouseOver = () => {
    clearTimeout(closeTimerRef.current);
    openTimerRef.current = setTimeout(() => {
      setOpen(true);
    }, openDelay);
  };
  const onMouseOut = () => {
    clearTimeout(openTimerRef.current);
    closeTimerRef.current = setTimeout(() => {
      setOpen(false);
    }, closeDelay);
  };
  const onFocus = () => {
    clearTimeout(closeTimerRef.current);
    openTimerRef.current = setTimeout(() => {
      setOpen(true);
    }, openDelay);
  };
  const onBlur = () => {
    clearTimeout(openTimerRef.current);
    closeTimerRef.current = setTimeout(() => {
      setOpen(false);
    }, closeDelay);
  };
  const handleKeyDown = event => {
    if (event.key === 'Escape') {
      closeTimerRef.current = setTimeout(() => {
        setOpen(false);
      }, closeDelay);
    }
  };
  useEffect(() => {
    document.addEventListener('keydown', handleKeyDown);
    return () => {
      clearTimeout(openTimerRef.current);
      clearTimeout(closeTimerRef.current);
      document.removeEventListener('keydown', handleKeyDown);
    };
  }, []);
  return /*#__PURE__*/React.createElement(React.Fragment, null, typeof children === 'function' ? children({
    onMouseOver: onMouseOver,
    onMouseOut: onMouseOut,
    onFocus: {
      onFocus
    },
    onBlur: {
      onBlur
    },
    ref: popperReference
  }) : /*#__PURE__*/React.createElement("span", {
    onMouseOver: onMouseOver,
    onMouseOut: onMouseOut,
    onFocus: onFocus,
    onBlur: onBlur,
    ref: popperReference,
    tabIndex: 0,
    "aria-describedby": open ? 'tooltipContenDhis2Ui' : '',
    "data-test": `${dataTest}-reference`,
    className: _JSXStyle.dynamic([["3515683788", [maxWidth, colors.grey900, colors.white]]])
  }, children), open && /*#__PURE__*/React.createElement(Portal, null, /*#__PURE__*/React.createElement(Popper, {
    className: popperStyle.className,
    placement: placement,
    reference: popperReference,
    modifiers: [offsetModifier, flipModifier, hideModifier]
  }, /*#__PURE__*/React.createElement("div", {
    id: "tooltipContenDhis2Ui",
    onMouseOver: onMouseOver,
    onMouseOut: onMouseOut,
    "data-test": `${dataTest}-content`,
    role: "tooltip",
    className: _JSXStyle.dynamic([["3515683788", [maxWidth, colors.grey900, colors.white]]]) + " " + (className || "")
  }, content))), popperStyle.styles, /*#__PURE__*/React.createElement(_JSXStyle, {
    id: "3515683788",
    dynamic: [maxWidth, colors.grey900, colors.white]
  }, [`div.__jsx-style-dynamic-selector{max-width:${maxWidth}px;}`, `div.__jsx-style-dynamic-selector{padding:4px 6px;background-color:${colors.grey900};border-radius:3px;color:${colors.white};font-size:13px;line-height:17px;}`]));
};
Tooltip.propTypes = {
  /** If child is a function, it's called with `{ onMouseOver, onMouseOut, ref }` args to apply to a reference element. If child is a node, it is wrapped in a `span` with the appropriate attributes and handlers. */
  children: PropTypes.oneOfType([PropTypes.node, PropTypes.func]),
  className: PropTypes.string,
  /** Time (in ms) until tooltip closes after mouse out */
  closeDelay: PropTypes.number,
  /** Content to display when the tooltip is open */
  content: PropTypes.node,
  dataTest: PropTypes.string,
  /** Max width of the tooltip in px */
  maxWidth: PropTypes.number,
  /** Time (in ms) until tooltip open after mouse over */
  openDelay: PropTypes.number,
  /** Where to place the tooltip relative to its reference */
  placement: PropTypes.oneOf(['top', 'right', 'bottom', 'left'])
};
export { Tooltip, TOOLTIP_OFFSET };